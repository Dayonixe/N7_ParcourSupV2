// nom : marriage_algo
// sémantique: effectue l'algorithme du marriage stable pour parcousupv2
// paramètres:
// écoles : In/Out list<école>; -- Rôle du paramètre
// étudiants : In/Out list<étudiant>; -- liste d'étudiants
// nbRound : Out Envier; -- nombre round pour la résolution du problème
// pré-condition: sum(ecole.capacité) >= sum(eleve)
// post-condition: 
//      -- Tous les étudiants sont répartis dans les "postulants" des différentes écoles
//      -- Tous les étudiants possèdent une école
fonction marriage_algo(étudiants: list<étudiant>; écoles: list<école>) : Integer
début
    nbRound := 0
    etudiants_non_assignés := copy(etudiants)
    tant que (non etudiants_non_assignés.est_vide()) faire
        // Matin : Tous les etudiants sans école postulent à une école
        pour etudiant dans etudiants_non_assignés faire
            prefSchool := etudiant.getFirstChoice()
            prefSchool.addPostulant(etudiant)
        fpour
        etudiants_non_assignés := list() // remise à zéro de la liste

        // Après-midi : Les écoles vérifient si leur capacité n'est pas dépassée, auquel cas elles suppriment les étudiants les moins désirés
        pour ecole dans ecoles faire
            si ecole.surchagé alors // conflit
                pour eleve dans ecole.refuseEleves() faire
                    etudiants_non_assignés.append(eleve)
                fpour
            fsi
        fpour

        // Soir : Les étudiants les moins désirés supprime leur premier choix
        pour etudiant dans etudiants_non_assignés faire
            etudiant.supprimerPremierChoix()
        fpour

        nbRound := nbRound + 1
        
    ftant
        
    retourne nbRound
fin